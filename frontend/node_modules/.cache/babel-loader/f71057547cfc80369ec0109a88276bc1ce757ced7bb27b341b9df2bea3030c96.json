{"ast":null,"code":"import React, { useMemo, useImperativeHandle, useLayoutEffect } from 'react';\nimport { useMap } from '../hooks/useMap.js';\n\n/**\r\n * `API` 사용자가 직접 정의할 수 있는 오버레이.\r\n * AbstractOverlay를 상속 받아 사용할 객체를 생성하고 prototype을 연결해 준다.\r\n * 온전히 동작하는 오버레이를 만들고자 한다면 3가지 인터페이스 메소드( onAdd, draw, onRemove )를 구현해야 한다.\r\n *\r\n * 해당 Component 내부에서 `ReactAbstractOveraly` class를 만들어 `onAdd`, `draw`, `onRemove` 를 연결한 후 React Life Cycle에 맞춰 `setMap` 를 자동으로 호출 합니다.\r\n *\r\n * *경고* `draw`, `onAdd`, `onRemove` 의 경우 반드시 익명함수가 **아닌** 형태로 만들어서 전달해야 합니다.\r\n * `this.~` 를 통한 접근이 가능하니 해당 부분을 이용해서 구현 해주세요!\r\n *\r\n * ### Example Code\r\n *\r\n * ```jsx live\r\n * function () {\r\n *  const TooltipMarker = ({\r\n *    position,\r\n *  }) => {\r\n *    const node = useRef(document.createElement(\"div\"))\r\n *\r\n *    const positionLatlng = useMemo(() => {\r\n *      return new kakao.maps.LatLng(position.lat, position.lng)\r\n *    }, [position.lat, position.lng])\r\n *\r\n *    function onAdd() {\r\n *      const panel = this.getPanels()\r\n *        .overlayLayer\r\n *      panel.appendChild(node.current)\r\n *    }\r\n *\r\n *    function onRemove() {\r\n *      node.current.parentNode.removeChild(node.current)\r\n *    }\r\n *\r\n *    function draw() {\r\n *      var projection = this.getProjection()\r\n *      var point = projection.pointFromCoords(positionLatlng)\r\n *      var width = node.current.offsetWidth\r\n *      var height = node.current.offsetHeight\r\n *\r\n *      console.log(point, width, height)\r\n *\r\n *      node.current.style.left = point.x - width / 2 + \"px\"\r\n *      node.current.style.top = point.y - height / 2 + \"px\"\r\n *    }\r\n *\r\n *    useEffect(() => {\r\n *      node.current.style.position = \"absolute\"\r\n *      node.current.style.whiteSpace = \"nowrap\"\r\n *    }, [])\r\n *\r\n *    return (\r\n *      <>\r\n *        <AbstractOverlay onAdd={onAdd} onRemove={onRemove} draw={draw} />\r\n *        {ReactDOM.createPortal(\r\n *          <div\r\n *            style={{\r\n *              color: \"#000\",\r\n *              backgroundColor: \"#fff\",\r\n *              padding: \"5px\",\r\n *              borderRadius: \"15px\",\r\n *            }}\r\n *          >\r\n *            Hello Marker!\r\n *          </div>,\r\n *          node.current\r\n *        )}\r\n *      </>\r\n *    )\r\n *  }\r\n *\r\n *  return (\r\n *    <>\r\n *      <Map // 지도를 표시할 Container\r\n *        center={{\r\n *          // 지도의 중심좌표\r\n *          lat: 37.54699,\r\n *          lng: 127.09598,\r\n *        }}\r\n *        style={{\r\n *          // 지도의 크기\r\n *          width: \"100%\",\r\n *          height: \"450px\",\r\n *        }}\r\n *        level={3} // 지도의 확대 레벨\r\n *      >\r\n *        <TooltipMarker\r\n *          position={{\r\n *            lat: 37.54699,\r\n *            lng: 127.09598,\r\n *          }}\r\n *        />\r\n *      </Map>\r\n *    </>\r\n *  )\r\n *}\r\n * ```\r\n */\nconst AbstractOverlay = /*#__PURE__*/React.forwardRef(function AbstractOverlay(_ref, ref) {\n  let {\n    draw,\n    onAdd,\n    onRemove,\n    onCreate\n  } = _ref;\n  const map = useMap();\n  const reactAbstractOverlay = useMemo(() => {\n    class ReactAbstractOveraly extends kakao.maps.AbstractOverlay {\n      constructor(draw, onAdd, onRemove) {\n        super();\n        this.draw = draw;\n        this.onAdd = onAdd;\n        this.onRemove = onRemove;\n      }\n    }\n    const overlay = new ReactAbstractOveraly(draw, onAdd, onRemove);\n    return overlay;\n  }, [draw, onAdd, onRemove]);\n  useImperativeHandle(ref, () => reactAbstractOverlay, [reactAbstractOverlay]);\n  useLayoutEffect(() => {\n    reactAbstractOverlay.setMap(map);\n    return () => {\n      reactAbstractOverlay.setMap(null);\n    };\n  }, [map, reactAbstractOverlay]);\n  useLayoutEffect(() => {\n    if (onCreate) onCreate(reactAbstractOverlay);\n  }, [reactAbstractOverlay, onCreate]);\n  return null;\n});\nexport { AbstractOverlay };","map":{"version":3,"names":["React","useMemo","useImperativeHandle","useLayoutEffect","useMap","AbstractOverlay","forwardRef","_ref","ref","draw","onAdd","onRemove","onCreate","map","reactAbstractOverlay","ReactAbstractOveraly","kakao","maps","constructor","overlay","setMap"],"sources":["C:/Users/by_95/Desktop/2024/Web_Programming/ReBread/pingpong/frontend/node_modules/react-kakao-maps-sdk/esm/components/AbstractOverlay.js"],"sourcesContent":["import React, { useMemo, useImperativeHandle, useLayoutEffect } from 'react';\r\nimport { useMap } from '../hooks/useMap.js';\r\n\r\n/**\r\n * `API` 사용자가 직접 정의할 수 있는 오버레이.\r\n * AbstractOverlay를 상속 받아 사용할 객체를 생성하고 prototype을 연결해 준다.\r\n * 온전히 동작하는 오버레이를 만들고자 한다면 3가지 인터페이스 메소드( onAdd, draw, onRemove )를 구현해야 한다.\r\n *\r\n * 해당 Component 내부에서 `ReactAbstractOveraly` class를 만들어 `onAdd`, `draw`, `onRemove` 를 연결한 후 React Life Cycle에 맞춰 `setMap` 를 자동으로 호출 합니다.\r\n *\r\n * *경고* `draw`, `onAdd`, `onRemove` 의 경우 반드시 익명함수가 **아닌** 형태로 만들어서 전달해야 합니다.\r\n * `this.~` 를 통한 접근이 가능하니 해당 부분을 이용해서 구현 해주세요!\r\n *\r\n * ### Example Code\r\n *\r\n * ```jsx live\r\n * function () {\r\n *  const TooltipMarker = ({\r\n *    position,\r\n *  }) => {\r\n *    const node = useRef(document.createElement(\"div\"))\r\n *\r\n *    const positionLatlng = useMemo(() => {\r\n *      return new kakao.maps.LatLng(position.lat, position.lng)\r\n *    }, [position.lat, position.lng])\r\n *\r\n *    function onAdd() {\r\n *      const panel = this.getPanels()\r\n *        .overlayLayer\r\n *      panel.appendChild(node.current)\r\n *    }\r\n *\r\n *    function onRemove() {\r\n *      node.current.parentNode.removeChild(node.current)\r\n *    }\r\n *\r\n *    function draw() {\r\n *      var projection = this.getProjection()\r\n *      var point = projection.pointFromCoords(positionLatlng)\r\n *      var width = node.current.offsetWidth\r\n *      var height = node.current.offsetHeight\r\n *\r\n *      console.log(point, width, height)\r\n *\r\n *      node.current.style.left = point.x - width / 2 + \"px\"\r\n *      node.current.style.top = point.y - height / 2 + \"px\"\r\n *    }\r\n *\r\n *    useEffect(() => {\r\n *      node.current.style.position = \"absolute\"\r\n *      node.current.style.whiteSpace = \"nowrap\"\r\n *    }, [])\r\n *\r\n *    return (\r\n *      <>\r\n *        <AbstractOverlay onAdd={onAdd} onRemove={onRemove} draw={draw} />\r\n *        {ReactDOM.createPortal(\r\n *          <div\r\n *            style={{\r\n *              color: \"#000\",\r\n *              backgroundColor: \"#fff\",\r\n *              padding: \"5px\",\r\n *              borderRadius: \"15px\",\r\n *            }}\r\n *          >\r\n *            Hello Marker!\r\n *          </div>,\r\n *          node.current\r\n *        )}\r\n *      </>\r\n *    )\r\n *  }\r\n *\r\n *  return (\r\n *    <>\r\n *      <Map // 지도를 표시할 Container\r\n *        center={{\r\n *          // 지도의 중심좌표\r\n *          lat: 37.54699,\r\n *          lng: 127.09598,\r\n *        }}\r\n *        style={{\r\n *          // 지도의 크기\r\n *          width: \"100%\",\r\n *          height: \"450px\",\r\n *        }}\r\n *        level={3} // 지도의 확대 레벨\r\n *      >\r\n *        <TooltipMarker\r\n *          position={{\r\n *            lat: 37.54699,\r\n *            lng: 127.09598,\r\n *          }}\r\n *        />\r\n *      </Map>\r\n *    </>\r\n *  )\r\n *}\r\n * ```\r\n */\r\nconst AbstractOverlay = /*#__PURE__*/React.forwardRef(function AbstractOverlay(_ref, ref) {\r\n  let {\r\n    draw,\r\n    onAdd,\r\n    onRemove,\r\n    onCreate\r\n  } = _ref;\r\n  const map = useMap();\r\n  const reactAbstractOverlay = useMemo(() => {\r\n    class ReactAbstractOveraly extends kakao.maps.AbstractOverlay {\r\n      constructor(draw, onAdd, onRemove) {\r\n        super();\r\n        this.draw = draw;\r\n        this.onAdd = onAdd;\r\n        this.onRemove = onRemove;\r\n      }\r\n    }\r\n    const overlay = new ReactAbstractOveraly(draw, onAdd, onRemove);\r\n    return overlay;\r\n  }, [draw, onAdd, onRemove]);\r\n  useImperativeHandle(ref, () => reactAbstractOverlay, [reactAbstractOverlay]);\r\n  useLayoutEffect(() => {\r\n    reactAbstractOverlay.setMap(map);\r\n    return () => {\r\n      reactAbstractOverlay.setMap(null);\r\n    };\r\n  }, [map, reactAbstractOverlay]);\r\n  useLayoutEffect(() => {\r\n    if (onCreate) onCreate(reactAbstractOverlay);\r\n  }, [reactAbstractOverlay, onCreate]);\r\n  return null;\r\n});\r\n\r\nexport { AbstractOverlay };\r\n"],"mappings":"AAAA,OAAOA,KAAK,IAAIC,OAAO,EAAEC,mBAAmB,EAAEC,eAAe,QAAQ,OAAO;AAC5E,SAASC,MAAM,QAAQ,oBAAoB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,eAAe,GAAG,aAAaL,KAAK,CAACM,UAAU,CAAC,SAASD,eAAeA,CAACE,IAAI,EAAEC,GAAG,EAAE;EACxF,IAAI;IACFC,IAAI;IACJC,KAAK;IACLC,QAAQ;IACRC;EACF,CAAC,GAAGL,IAAI;EACR,MAAMM,GAAG,GAAGT,MAAM,CAAC,CAAC;EACpB,MAAMU,oBAAoB,GAAGb,OAAO,CAAC,MAAM;IACzC,MAAMc,oBAAoB,SAASC,KAAK,CAACC,IAAI,CAACZ,eAAe,CAAC;MAC5Da,WAAWA,CAACT,IAAI,EAAEC,KAAK,EAAEC,QAAQ,EAAE;QACjC,KAAK,CAAC,CAAC;QACP,IAAI,CAACF,IAAI,GAAGA,IAAI;QAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;QAClB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;MAC1B;IACF;IACA,MAAMQ,OAAO,GAAG,IAAIJ,oBAAoB,CAACN,IAAI,EAAEC,KAAK,EAAEC,QAAQ,CAAC;IAC/D,OAAOQ,OAAO;EAChB,CAAC,EAAE,CAACV,IAAI,EAAEC,KAAK,EAAEC,QAAQ,CAAC,CAAC;EAC3BT,mBAAmB,CAACM,GAAG,EAAE,MAAMM,oBAAoB,EAAE,CAACA,oBAAoB,CAAC,CAAC;EAC5EX,eAAe,CAAC,MAAM;IACpBW,oBAAoB,CAACM,MAAM,CAACP,GAAG,CAAC;IAChC,OAAO,MAAM;MACXC,oBAAoB,CAACM,MAAM,CAAC,IAAI,CAAC;IACnC,CAAC;EACH,CAAC,EAAE,CAACP,GAAG,EAAEC,oBAAoB,CAAC,CAAC;EAC/BX,eAAe,CAAC,MAAM;IACpB,IAAIS,QAAQ,EAAEA,QAAQ,CAACE,oBAAoB,CAAC;EAC9C,CAAC,EAAE,CAACA,oBAAoB,EAAEF,QAAQ,CAAC,CAAC;EACpC,OAAO,IAAI;AACb,CAAC,CAAC;AAEF,SAASP,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}